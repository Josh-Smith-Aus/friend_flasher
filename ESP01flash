#include <ESP8266WiFi.h>
#include <WiFiManager.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <Adafruit_NeoPixel.h>
#include <ArduinoOTA.h>

// ----- LED CONFIG -----
#define LED_PIN 2
#define NUM_LEDS 10

Adafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

// ----- HARD-CODED PREFIX -----
const char* DEVICE_PREFIX = "josh";

// ----- UNIQUE DEVICE ID -----
String getDeviceID() {
  uint32_t chipId = ESP.getChipId();
  char idStr[9];
  snprintf(idStr, sizeof(idStr), "%s%04X", DEVICE_PREFIX, chipId & 0xFFFF);
  return String(idStr);
}

// ----- MQTT CONFIG -----
String deviceID;
String mqtt_topic;

const char* mqtt_server = "test.mosquitto.org";
const int mqtt_port = 1883;

// ----- CLIENTS -----
WiFiClient espClient;
PubSubClient client(espClient);

// ----- STATE -----
unsigned long lastBlink = 0;
bool blinkState = false;
unsigned long wifiLostTimestamp = 0;
unsigned long lastMqttReconnect = 0;
const unsigned long TIMEOUT_BEFORE_AP = 120000;  // 2 minutes
const unsigned long MQTT_RECONNECT_INTERVAL = 5000;  // 5 seconds

// ----- FUNCTIONS -----
void blinkFirstLEDRed() {
  unsigned long now = millis();
  if (now - lastBlink > 500) {
    blinkState = !blinkState;
    strip.setPixelColor(0, blinkState ? strip.Color(255, 0, 0) : strip.Color(0, 0, 0));
    strip.show();
    lastBlink = now;
  }
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  StaticJsonDocument<512> doc;
  DeserializationError error = deserializeJson(doc, payload, length);
  if (error) {
    Serial.print("JSON parse error: ");
    Serial.println(error.c_str());
    return;
  }

  if (doc.containsKey("leds")) {
    JsonArray leds = doc["leds"].as<JsonArray>();

    for (JsonObject led : leds) {
      if (!led.containsKey("i") || !led.containsKey("c")) continue;

      int index = led["i"];
      if (index < 0 || index >= NUM_LEDS) continue;

      String hex = led["c"];
      uint8_t brightness = led.containsKey("b") ? led["b"] : 255;

      // Validate hex format
      if (hex.length() < 7 || hex[0] != '#') continue;

      long color = strtol(hex.substring(1).c_str(), NULL, 16);
      uint8_t r = (color >> 16) & 0xFF;
      uint8_t g = (color >> 8) & 0xFF;
      uint8_t b = color & 0xFF;

      // Apply brightness scaling
      r = (r * brightness) / 255;
      g = (g * brightness) / 255;
      b = (b * brightness) / 255;

      strip.setPixelColor(index, strip.Color(r, g, b));
    }
    strip.show();
  }
}

void reconnectMQTT() {
  // Non-blocking reconnect with timeout
  if (millis() - lastMqttReconnect < MQTT_RECONNECT_INTERVAL) {
    return;
  }
  
  lastMqttReconnect = millis();
  
  if (client.connect(deviceID.c_str())) {
    Serial.println("MQTT connected");
    client.subscribe(mqtt_topic.c_str());
    Serial.print("Subscribed to: ");
    Serial.println(mqtt_topic);
  } else {
    Serial.print("MQTT connection failed, rc=");
    Serial.println(client.state());
  }
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println();
  Serial.println("Booting...");
  
  // Initialize LED strip first
  strip.begin();
  strip.clear();
  strip.show();

  deviceID = getDeviceID();
  mqtt_topic = "lights/" + deviceID + "/control";
  
  Serial.print("Device ID: ");
  Serial.println(deviceID);
  Serial.print("MQTT Topic: ");
  Serial.println(mqtt_topic);

  // WiFi setup
  WiFiManager wifiManager;
  wifiManager.setConfigPortalTimeout(180);  // 3 minute timeout for config portal
  
  if (!wifiManager.autoConnect("ESP_Config_AP")) {
    Serial.println("Failed to connect, restarting...");
    delay(3000);
    ESP.restart();
  }

  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());

  // MQTT setup
  client.setServer(mqtt_server, mqtt_port);
  client.setCallback(mqttCallback);
  client.setKeepAlive(60);  // Increase keepalive to 60 seconds

  // OTA Setup
  ArduinoOTA.setHostname(deviceID.c_str());
  ArduinoOTA.setPassword("josh");
  
  ArduinoOTA.onStart([]() {
    String type = (ArduinoOTA.getCommand() == U_FLASH) ? "sketch" : "filesystem";
    Serial.println("Start updating " + type);
    strip.clear();
    strip.show();
  });
  
  ArduinoOTA.onEnd([]() {
    Serial.println("\nEnd");
  });
  
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    // Show progress on first LED
    uint8_t brightness = (progress * 255) / total;
    strip.setPixelColor(0, strip.Color(0, 0, brightness));
    strip.show();
  });
  
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR) Serial.println("End Failed");
  });
  
  ArduinoOTA.begin();
  Serial.println("OTA Ready");
}

void loop() {
  ArduinoOTA.handle();

  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    if (wifiLostTimestamp == 0) {
      wifiLostTimestamp = millis();
      Serial.println("WiFi connection lost");
    }

    // After timeout, restart to trigger WiFiManager
    if (millis() - wifiLostTimestamp > TIMEOUT_BEFORE_AP) {
      Serial.println("WiFi timeout - restarting to config portal");
      delay(1000);
      ESP.restart();
    }

    blinkFirstLEDRed();
    delay(100);  // Small delay to prevent tight loop
    return;
  } else {
    // WiFi connected - reset timer
    if (wifiLostTimestamp != 0) {
      Serial.println("WiFi reconnected");
      wifiLostTimestamp = 0;
    }
  }

  // Handle MQTT connection
  if (!client.connected()) {
    reconnectMQTT();
  } else {
    client.loop();
  }
  
  // Small yield to prevent watchdog reset
  yield();
}
