// To use with esp32 instead with https update


#include <WiFi.h>
#include <WiFiManager.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <Adafruit_NeoPixel.h>
#include <HTTPUpdate.h>

// ----- VERSION INFO -----
#define FIRMWARE_VERSION "1.0.0"

// ----- LED CONFIG -----
#define LED_PIN 2
#define NUM_LEDS 10

Adafruit_NeoPixel strip(NUM_LEDS, LED_PIN, NEO_GRB + NEO_KHZ800);

// ----- HARD-CODED PREFIX -----
const char* DEVICE_PREFIX = "light";  // Changed for commercial product

// ----- UNIQUE DEVICE ID -----
String getDeviceID() {
  uint64_t chipId = ESP.getEfuseMac();
  char idStr[13];
  snprintf(idStr, sizeof(idStr), "%s%08X", DEVICE_PREFIX, (uint32_t)chipId);
  return String(idStr);
}

// ----- MQTT CONFIG -----
String deviceID;
String mqtt_topic;
String mqtt_update_topic;

// UPDATE THESE FOR PRODUCTION
const char* mqtt_server = "your-server.com";  // Your server
const int mqtt_port = 8883;
const char* mqtt_user = "device";
const char* mqtt_pass = "secure_password_here";

// Firmware update URL
const char* firmware_url = "https://your-server.com/firmware/latest.bin";

// ----- CLIENTS -----
WiFiClientSecure espClient;
PubSubClient client(espClient);

// ----- STATE -----
unsigned long lastBlink = 0;
bool blinkState = false;
unsigned long wifiLostTimestamp = 0;
unsigned long lastMqttReconnect = 0;
const unsigned long TIMEOUT_BEFORE_AP = 120000;
const unsigned long MQTT_RECONNECT_INTERVAL = 5000;

// ----- EFFECT STATE -----
struct Effect {
  bool active;
  int ledIndex;
  String type;
  uint8_t baseR, baseG, baseB;
  unsigned long lastUpdate;
  uint16_t speed;
  uint8_t step;
};

Effect currentEffect = {false, -1, "none", 0, 0, 0, 0, 20, 0};

// ----- FUNCTIONS -----
void setStatusLED(uint8_t r, uint8_t g, uint8_t b) {
  strip.setPixelColor(0, strip.Color(r, g, b));
  strip.show();
}

void blinkStatusLED(uint8_t r, uint8_t g, uint8_t b) {
  unsigned long now = millis();
  if (now - lastBlink > 500) {
    blinkState = !blinkState;
    strip.setPixelColor(0, blinkState ? strip.Color(r, g, b) : strip.Color(0, 0, 0));
    strip.show();
    lastBlink = now;
  }
}

void performFirmwareUpdate() {
  Serial.println("Starting firmware update...");
  setStatusLED(255, 0, 255);  // Magenta during update
  
  // Publish update status
  StaticJsonDocument<128> statusDoc;
  statusDoc["status"] = "updating";
  statusDoc["version"] = FIRMWARE_VERSION;
  char buffer[128];
  serializeJson(statusDoc, buffer);
  client.publish((mqtt_topic + "/status").c_str(), buffer);
  
  WiFiClientSecure updateClient;
  updateClient.setInsecure();  // For production, use proper cert validation
  
  httpUpdate.setLedPin(LED_BUILTIN, LOW);
  
  httpUpdate.onStart([]() {
    Serial.println("Update started");
  });
  
  httpUpdate.onEnd([]() {
    Serial.println("Update finished");
  });
  
  httpUpdate.onProgress([](int cur, int total) {
    Serial.printf("Update progress: %d%%\r", (cur * 100) / total);
    // Show progress on status LED
    uint8_t brightness = (cur * 255) / total;
    strip.setPixelColor(0, strip.Color(brightness, 0, 255 - brightness));
    strip.show();
  });
  
  httpUpdate.onError([](int err) {
    Serial.printf("Update error: %d\n", err);
    setStatusLED(255, 0, 0);  // Red on error
  });
  
  t_httpUpdate_return ret = httpUpdate.update(updateClient, firmware_url);
  
  switch (ret) {
    case HTTP_UPDATE_FAILED:
      Serial.printf("Update failed: %s\n", httpUpdate.getLastErrorString().c_str());
      
      // Publish failure status
      statusDoc.clear();
      statusDoc["status"] = "failed";
      statusDoc["error"] = httpUpdate.getLastErrorString();
      serializeJson(statusDoc, buffer);
      client.publish((mqtt_topic + "/status").c_str(), buffer);
      break;
      
    case HTTP_UPDATE_NO_UPDATES:
      Serial.println("No update available");
      
      statusDoc.clear();
      statusDoc["status"] = "up_to_date";
      statusDoc["version"] = FIRMWARE_VERSION;
      serializeJson(statusDoc, buffer);
      client.publish((mqtt_topic + "/status").c_str(), buffer);
      break;
      
    case HTTP_UPDATE_OK:
      Serial.println("Update OK, restarting...");
      // Device will restart automatically
      break;
  }
}

void updateEffects() {
  if (!currentEffect.active) return;
  
  unsigned long now = millis();
  if (now - currentEffect.lastUpdate < currentEffect.speed) return;
  
  currentEffect.lastUpdate = now;
  
  if (currentEffect.type == "pulse") {
    currentEffect.step = (currentEffect.step + 1) % 256;
    uint8_t brightness = (sin(currentEffect.step * 0.0245) + 1) * 127.5;
    
    uint8_t r = (currentEffect.baseR * brightness) / 255;
    uint8_t g = (currentEffect.baseG * brightness) / 255;
    uint8_t b = (currentEffect.baseB * brightness) / 255;
    
    strip.setPixelColor(currentEffect.ledIndex, strip.Color(r, g, b));
    strip.show();
    
  } else if (currentEffect.type == "breathe") {
    currentEffect.step = (currentEffect.step + 1) % 512;
    uint8_t brightness = (sin(currentEffect.step * 0.01227) + 1) * 127.5;
    
    uint8_t r = (currentEffect.baseR * brightness) / 255;
    uint8_t g = (currentEffect.baseG * brightness) / 255;
    uint8_t b = (currentEffect.baseB * brightness) / 255;
    
    strip.setPixelColor(currentEffect.ledIndex, strip.Color(r, g, b));
    strip.show();
    
  } else if (currentEffect.type == "rainbow") {
    currentEffect.step = (currentEffect.step + 1) % 256;
    
    for (int i = 1; i < NUM_LEDS; i++) {
      uint8_t hue = (currentEffect.step + (i * 256 / NUM_LEDS)) % 256;
      uint32_t color = strip.ColorHSV(hue * 256);
      strip.setPixelColor(i, color);
    }
    strip.show();
  }
}

void startEffect(String type, int ledIndex, uint8_t r, uint8_t g, uint8_t b, String speed) {
  currentEffect.active = true;
  currentEffect.type = type;
  currentEffect.ledIndex = ledIndex;
  currentEffect.baseR = r;
  currentEffect.baseG = g;
  currentEffect.baseB = b;
  currentEffect.step = 0;
  currentEffect.lastUpdate = millis();
  
  if (speed == "slow") {
    currentEffect.speed = 40;
  } else if (speed == "fast") {
    currentEffect.speed = 10;
  } else {
    currentEffect.speed = 20;
  }
}

void stopEffect() {
  currentEffect.active = false;
  currentEffect.type = "none";
}

void mqttCallback(char* topic, byte* payload, unsigned int length) {
  StaticJsonDocument<512> doc;
  DeserializationError error = deserializeJson(doc, payload, length);
  if (error) {
    Serial.print("JSON parse error: ");
    Serial.println(error.c_str());
    return;
  }

  // Check for update command
  if (doc.containsKey("update")) {
    if (doc["update"] == true || doc["update"] == "now") {
      performFirmwareUpdate();
      return;
    }
  }

  // Check for effect command
  if (doc.containsKey("effect")) {
    String effectType = doc["effect"].as<String>();
    
    if (effectType == "none") {
      stopEffect();
      return;
    }
    
    if (effectType == "rainbow") {
      startEffect("rainbow", -1, 0, 0, 0, doc.containsKey("speed") ? doc["speed"].as<String>() : "medium");
      return;
    }
    
    if (effectType == "pulse" || effectType == "breathe") {
      if (!doc.containsKey("led") || !doc.containsKey("color")) {
        return;
      }
      
      int ledIndex = doc["led"];
      String hex = doc["color"];
      String speed = doc.containsKey("speed") ? doc["speed"].as<String>() : "medium";
      
      if (ledIndex < 0 || ledIndex >= NUM_LEDS) return;
      
      if (hex.length() >= 7 && hex[0] == '#') {
        long color = strtol(hex.substring(1).c_str(), NULL, 16);
        uint8_t r = (color >> 16) & 0xFF;
        uint8_t g = (color >> 8) & 0xFF;
        uint8_t b = color & 0xFF;
        
        startEffect(effectType, ledIndex, r, g, b, speed);
      }
      return;
    }
  }

  stopEffect();

  if (doc.containsKey("all")) {
    String hex = doc["all"];
    uint8_t brightness = doc.containsKey("b") ? doc["b"] : 255;

    if (hex.length() >= 7 && hex[0] == '#') {
      long color = strtol(hex.substring(1).c_str(), NULL, 16);
      uint8_t r = ((color >> 16) & 0xFF) * brightness / 255;
      uint8_t g = ((color >> 8) & 0xFF) * brightness / 255;
      uint8_t b = (color & 0xFF) * brightness / 255;

      for (int i = 1; i < NUM_LEDS; i++) {
        strip.setPixelColor(i, strip.Color(r, g, b));
      }
      strip.show();
    }
    return;
  }

  if (doc.containsKey("leds")) {
    JsonArray leds = doc["leds"].as<JsonArray>();

    for (JsonObject led : leds) {
      if (!led.containsKey("i") || !led.containsKey("c")) continue;

      int index = led["i"];
      if (index < 0 || index >= NUM_LEDS) continue;

      String hex = led["c"];
      uint8_t brightness = led.containsKey("b") ? led["b"] : 255;

      if (hex.length() < 7 || hex[0] != '#') continue;

      long color = strtol(hex.substring(1).c_str(), NULL, 16);
      uint8_t r = (color >> 16) & 0xFF;
      uint8_t g = (color >> 8) & 0xFF;
      uint8_t b = color & 0xFF;

      r = (r * brightness) / 255;
      g = (g * brightness) / 255;
      b = (b * brightness) / 255;

      strip.setPixelColor(index, strip.Color(r, g, b));
    }
    strip.show();
  }
}

void reconnectMQTT() {
  if (millis() - lastMqttReconnect < MQTT_RECONNECT_INTERVAL) {
    return;
  }
  
  lastMqttReconnect = millis();
  
  if (client.connect(deviceID.c_str(), mqtt_user, mqtt_pass)) {
    Serial.println("MQTT connected");
    client.subscribe(mqtt_topic.c_str());
    client.subscribe("lights/all/control");
    client.subscribe(mqtt_update_topic.c_str());  // Subscribe to update topic
    
    // Publish online status with version
    StaticJsonDocument<128> doc;
    doc["status"] = "online";
    doc["version"] = FIRMWARE_VERSION;
    doc["device_id"] = deviceID;
    char buffer[128];
    serializeJson(doc, buffer);
    client.publish((mqtt_topic + "/status").c_str(), buffer, true);  // Retained message
    
    Serial.print("Subscribed to: ");
    Serial.println(mqtt_topic);
    
    setStatusLED(0, 255, 0);
  } else {
    Serial.print("MQTT connection failed, rc=");
    Serial.println(client.state());
  }
}

void setup() {
  espClient.setInsecure();
  Serial.begin(115200);
  delay(1000);

  Serial.println();
  Serial.println("Booting ESP32 LED Controller...");
  Serial.print("Firmware version: ");
  Serial.println(FIRMWARE_VERSION);
  
  strip.begin();
  strip.clear();
  strip.show();
  
  setStatusLED(0, 0, 255);

  deviceID = getDeviceID();
  mqtt_topic = "lights/" + deviceID + "/control";
  mqtt_update_topic = "lights/" + deviceID + "/update";
  
  Serial.print("Device ID: ");
  Serial.println(deviceID);

  WiFiManager wifiManager;
  wifiManager.setConfigPortalTimeout(180);
  
  if (!wifiManager.autoConnect(deviceID.c_str())) {
    Serial.println("Failed to connect, restarting...");
    delay(3000);
    ESP.restart();
  }

  Serial.println("WiFi connected");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  
  setStatusLED(0, 255, 255);

  client.setServer(mqtt_server, mqtt_port);
  client.setBufferSize(512);
  client.setCallback(mqttCallback);
  client.setKeepAlive(60);

  Serial.println("Setup complete");
}

void loop() {
  updateEffects();
  
  if (WiFi.status() != WL_CONNECTED) {
    if (wifiLostTimestamp == 0) {
      wifiLostTimestamp = millis();
      Serial.println("WiFi connection lost");
      stopEffect();
    }

    if (millis() - wifiLostTimestamp > TIMEOUT_BEFORE_AP) {
      Serial.println("WiFi timeout - restarting to config portal");
      delay(1000);
      ESP.restart();
    }

    blinkStatusLED(255, 0, 0);
    delay(100);
    return;
  } else {
    if (wifiLostTimestamp != 0) {
      Serial.println("WiFi reconnected");
      wifiLostTimestamp = 0;
      setStatusLED(0, 255, 255);
    }
  }

  if (!client.connected()) {
    blinkStatusLED(255, 255, 0);
    reconnectMQTT();
  } else {
    client.loop();
  }
}
